{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\User\\\\Documents\\\\GitHub\\\\LearnFi\\\\learnfi\\\\src\\\\context\\\\CompoundContext.jsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect } from 'react';\nimport { compoundService } from '../services/compoundService';\n\n// Create context\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst CompoundContext = /*#__PURE__*/createContext();\n\n// Custom hook to use the compound context\nexport const useCompound = () => {\n  _s();\n  return useContext(CompoundContext);\n};\n_s(useCompound, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nexport const CompoundProvider = ({\n  children\n}) => {\n  _s2();\n  // Market data state\n  const [marketData, setMarketData] = useState([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  // User's compound state (simulated)\n  const [userCompound, setUserCompound] = useState({\n    supplied: {},\n    borrowed: {},\n    health: 100,\n    collateralValue: 0\n  });\n\n  // Fetch market data on mount\n  useEffect(() => {\n    const fetchMarketData = async () => {\n      try {\n        setIsLoading(true);\n        const data = await compoundService.getMarkets();\n        setMarketData(data);\n        setError(null);\n      } catch (error) {\n        console.error('Error fetching market data:', error);\n        setError('Failed to fetch market data');\n      } finally {\n        setIsLoading(false);\n      }\n    };\n    fetchMarketData();\n\n    // Refresh market data every 60 seconds\n    const intervalId = setInterval(fetchMarketData, 60000);\n    return () => clearInterval(intervalId);\n  }, []);\n\n  // Simulate supplying assets\n  const simulateSupply = async (tokenSymbol, amount) => {\n    try {\n      // Get current market data for the token\n      const market = marketData.find(m => m.symbol === tokenSymbol);\n      if (!market) {\n        throw new Error(`Market for ${tokenSymbol} not found`);\n      }\n\n      // Calculate cToken amount (simplified)\n      const exchangeRate = market.exchangeRate || 0.02; // Default if not available\n      const cTokenAmount = amount / exchangeRate;\n\n      // Update user's compound state\n      setUserCompound(prev => ({\n        ...prev,\n        supplied: {\n          ...prev.supplied,\n          [tokenSymbol]: (prev.supplied[tokenSymbol] || 0) + parseFloat(amount)\n        },\n        collateralValue: prev.collateralValue + parseFloat(amount) * market.price\n      }));\n      return {\n        success: true,\n        cTokenAmount,\n        message: `Successfully supplied ${amount} ${tokenSymbol}`\n      };\n    } catch (error) {\n      return {\n        success: false,\n        message: error.message\n      };\n    }\n  };\n\n  // Simulate borrowing assets\n  const simulateBorrow = async (tokenSymbol, amount) => {\n    try {\n      // Get current market data for the token\n      const market = marketData.find(m => m.symbol === tokenSymbol);\n      if (!market) {\n        throw new Error(`Market for ${tokenSymbol} not found`);\n      }\n\n      // Check if user has enough collateral\n      const borrowValueInUSD = parseFloat(amount) * market.price;\n      const maxBorrow = userCompound.collateralValue * 0.75; // 75% of collateral value\n\n      if (borrowValueInUSD > maxBorrow) {\n        throw new Error(`Not enough collateral to borrow ${amount} ${tokenSymbol}`);\n      }\n\n      // Update user's compound state\n      setUserCompound(prev => {\n        const newBorrowed = {\n          ...prev.borrowed,\n          [tokenSymbol]: (prev.borrowed[tokenSymbol] || 0) + parseFloat(amount)\n        };\n\n        // Calculate new health factor\n        const totalBorrowedValue = Object.entries(newBorrowed).reduce((total, [symbol, amt]) => {\n          const tokenMarket = marketData.find(m => m.symbol === symbol);\n          return total + amt * ((tokenMarket === null || tokenMarket === void 0 ? void 0 : tokenMarket.price) || 0);\n        }, 0);\n        const newHealth = prev.collateralValue > 0 ? prev.collateralValue / totalBorrowedValue * 100 : 100;\n        return {\n          ...prev,\n          borrowed: newBorrowed,\n          health: Math.min(newHealth, 100)\n        };\n      });\n      return {\n        success: true,\n        message: `Successfully borrowed ${amount} ${tokenSymbol}`\n      };\n    } catch (error) {\n      return {\n        success: false,\n        message: error.message\n      };\n    }\n  };\n\n  // Calculate APY for supplied assets\n  const calculateSupplyAPY = tokenSymbol => {\n    const market = marketData.find(m => m.symbol === tokenSymbol);\n    return market ? market.supplyApy : 0;\n  };\n\n  // Calculate APY for borrowed assets\n  const calculateBorrowAPY = tokenSymbol => {\n    const market = marketData.find(m => m.symbol === tokenSymbol);\n    return market ? market.borrowApy : 0;\n  };\n\n  // Value to be provided by the context\n  const value = {\n    marketData,\n    isLoading,\n    error,\n    userCompound,\n    simulateSupply,\n    simulateBorrow,\n    calculateSupplyAPY,\n    calculateBorrowAPY\n  };\n  return /*#__PURE__*/_jsxDEV(CompoundContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 163,\n    columnNumber: 5\n  }, this);\n};\n_s2(CompoundProvider, \"KZ/dJ9qwmaM+1wk2Mf7vrQPGf/Y=\");\n_c = CompoundProvider;\nvar _c;\n$RefreshReg$(_c, \"CompoundProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","compoundService","jsxDEV","_jsxDEV","CompoundContext","useCompound","_s","CompoundProvider","children","_s2","marketData","setMarketData","isLoading","setIsLoading","error","setError","userCompound","setUserCompound","supplied","borrowed","health","collateralValue","fetchMarketData","data","getMarkets","console","intervalId","setInterval","clearInterval","simulateSupply","tokenSymbol","amount","market","find","m","symbol","Error","exchangeRate","cTokenAmount","prev","parseFloat","price","success","message","simulateBorrow","borrowValueInUSD","maxBorrow","newBorrowed","totalBorrowedValue","Object","entries","reduce","total","amt","tokenMarket","newHealth","Math","min","calculateSupplyAPY","supplyApy","calculateBorrowAPY","borrowApy","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/User/Documents/GitHub/LearnFi/learnfi/src/context/CompoundContext.jsx"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect } from 'react';\nimport { compoundService } from '../services/compoundService';\n\n// Create context\nconst CompoundContext = createContext();\n\n// Custom hook to use the compound context\nexport const useCompound = () => useContext(CompoundContext);\n\nexport const CompoundProvider = ({ children }) => {\n  // Market data state\n  const [marketData, setMarketData] = useState([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  // User's compound state (simulated)\n  const [userCompound, setUserCompound] = useState({\n    supplied: {},\n    borrowed: {},\n    health: 100,\n    collateralValue: 0\n  });\n\n  // Fetch market data on mount\n  useEffect(() => {\n    const fetchMarketData = async () => {\n      try {\n        setIsLoading(true);\n        const data = await compoundService.getMarkets();\n        setMarketData(data);\n        setError(null);\n      } catch (error) {\n        console.error('Error fetching market data:', error);\n        setError('Failed to fetch market data');\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    fetchMarketData();\n    \n    // Refresh market data every 60 seconds\n    const intervalId = setInterval(fetchMarketData, 60000);\n    \n    return () => clearInterval(intervalId);\n  }, []);\n\n  // Simulate supplying assets\n  const simulateSupply = async (tokenSymbol, amount) => {\n    try {\n      // Get current market data for the token\n      const market = marketData.find(m => m.symbol === tokenSymbol);\n      if (!market) {\n        throw new Error(`Market for ${tokenSymbol} not found`);\n      }\n      \n      // Calculate cToken amount (simplified)\n      const exchangeRate = market.exchangeRate || 0.02; // Default if not available\n      const cTokenAmount = amount / exchangeRate;\n      \n      // Update user's compound state\n      setUserCompound(prev => ({\n        ...prev,\n        supplied: {\n          ...prev.supplied,\n          [tokenSymbol]: (prev.supplied[tokenSymbol] || 0) + parseFloat(amount)\n        },\n        collateralValue: prev.collateralValue + (parseFloat(amount) * market.price)\n      }));\n      \n      return {\n        success: true,\n        cTokenAmount,\n        message: `Successfully supplied ${amount} ${tokenSymbol}`\n      };\n    } catch (error) {\n      return {\n        success: false,\n        message: error.message\n      };\n    }\n  };\n\n  // Simulate borrowing assets\n  const simulateBorrow = async (tokenSymbol, amount) => {\n    try {\n      // Get current market data for the token\n      const market = marketData.find(m => m.symbol === tokenSymbol);\n      if (!market) {\n        throw new Error(`Market for ${tokenSymbol} not found`);\n      }\n      \n      // Check if user has enough collateral\n      const borrowValueInUSD = parseFloat(amount) * market.price;\n      const maxBorrow = userCompound.collateralValue * 0.75; // 75% of collateral value\n      \n      if (borrowValueInUSD > maxBorrow) {\n        throw new Error(`Not enough collateral to borrow ${amount} ${tokenSymbol}`);\n      }\n      \n      // Update user's compound state\n      setUserCompound(prev => {\n        const newBorrowed = {\n          ...prev.borrowed,\n          [tokenSymbol]: (prev.borrowed[tokenSymbol] || 0) + parseFloat(amount)\n        };\n        \n        // Calculate new health factor\n        const totalBorrowedValue = Object.entries(newBorrowed)\n          .reduce((total, [symbol, amt]) => {\n            const tokenMarket = marketData.find(m => m.symbol === symbol);\n            return total + (amt * (tokenMarket?.price || 0));\n          }, 0);\n        \n        const newHealth = prev.collateralValue > 0 \n          ? (prev.collateralValue / totalBorrowedValue) * 100\n          : 100;\n        \n        return {\n          ...prev,\n          borrowed: newBorrowed,\n          health: Math.min(newHealth, 100)\n        };\n      });\n      \n      return {\n        success: true,\n        message: `Successfully borrowed ${amount} ${tokenSymbol}`\n      };\n    } catch (error) {\n      return {\n        success: false,\n        message: error.message\n      };\n    }\n  };\n\n  // Calculate APY for supplied assets\n  const calculateSupplyAPY = (tokenSymbol) => {\n    const market = marketData.find(m => m.symbol === tokenSymbol);\n    return market ? market.supplyApy : 0;\n  };\n\n  // Calculate APY for borrowed assets\n  const calculateBorrowAPY = (tokenSymbol) => {\n    const market = marketData.find(m => m.symbol === tokenSymbol);\n    return market ? market.borrowApy : 0;\n  };\n\n  // Value to be provided by the context\n  const value = {\n    marketData,\n    isLoading,\n    error,\n    userCompound,\n    simulateSupply,\n    simulateBorrow,\n    calculateSupplyAPY,\n    calculateBorrowAPY\n  };\n\n  return (\n    <CompoundContext.Provider value={value}>\n      {children}\n    </CompoundContext.Provider>\n  );\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}