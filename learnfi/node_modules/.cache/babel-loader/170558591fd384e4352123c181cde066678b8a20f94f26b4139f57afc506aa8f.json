{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\User\\\\Documents\\\\GitHub\\\\LearnFi\\\\learnfi\\\\src\\\\context\\\\CompoundContext.jsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect } from 'react';\nimport { compoundService } from '../services/compoundService';\n\n// Create context\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst CompoundContext = /*#__PURE__*/createContext();\n\n// Custom hook to use the compound context\nexport const useCompound = () => {\n  _s();\n  return useContext(CompoundContext);\n};\n_s(useCompound, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nexport const CompoundProvider = ({\n  children\n}) => {\n  _s2();\n  // Market data state\n  const [marketData, setMarketData] = useState({\n    markets: [],\n    loading: true,\n    error: null\n  });\n\n  // User's compound state (simulated)\n  const [userCompound, setUserCompound] = useState({\n    supplied: {},\n    borrowed: {},\n    health: 100,\n    collateralValue: 0\n  });\n\n  // Fetch market data on mount\n  useEffect(() => {\n    const fetchMarketData = async () => {\n      try {\n        const data = await compoundService.getMarkets();\n        setMarketData({\n          markets: data,\n          loading: false,\n          error: null\n        });\n      } catch (error) {\n        setMarketData({\n          markets: [],\n          loading: false,\n          error: error.message\n        });\n      }\n    };\n    fetchMarketData();\n\n    // Refresh market data every 60 seconds\n    const intervalId = setInterval(fetchMarketData, 60000);\n    return () => clearInterval(intervalId);\n  }, []);\n\n  // Simulate supplying assets\n  const simulateSupply = async (tokenSymbol, amount) => {\n    try {\n      // Get current market data for the token\n      const market = marketData.markets.find(m => m.symbol === tokenSymbol);\n      if (!market) {\n        throw new Error(`Market for ${tokenSymbol} not found`);\n      }\n\n      // Calculate cToken amount (simplified)\n      const exchangeRate = market.exchangeRate || 0.02; // Default if not available\n      const cTokenAmount = amount / exchangeRate;\n\n      // Update user's compound state\n      setUserCompound(prev => ({\n        ...prev,\n        supplied: {\n          ...prev.supplied,\n          [tokenSymbol]: (prev.supplied[tokenSymbol] || 0) + parseFloat(amount)\n        },\n        collateralValue: prev.collateralValue + parseFloat(amount) * market.price\n      }));\n      return {\n        success: true,\n        cTokenAmount,\n        message: `Successfully supplied ${amount} ${tokenSymbol}`\n      };\n    } catch (error) {\n      return {\n        success: false,\n        message: error.message\n      };\n    }\n  };\n\n  // Simulate borrowing assets\n  const simulateBorrow = async (tokenSymbol, amount) => {\n    try {\n      // Get current market data for the token\n      const market = marketData.markets.find(m => m.symbol === tokenSymbol);\n      if (!market) {\n        throw new Error(`Market for ${tokenSymbol} not found`);\n      }\n\n      // Check if user has enough collateral\n      const borrowValueInUSD = parseFloat(amount) * market.price;\n      const maxBorrow = userCompound.collateralValue * 0.75; // 75% of collateral value\n\n      if (borrowValueInUSD > maxBorrow) {\n        throw new Error(`Not enough collateral to borrow ${amount} ${tokenSymbol}`);\n      }\n\n      // Update user's compound state\n      setUserCompound(prev => {\n        const newBorrowed = {\n          ...prev.borrowed,\n          [tokenSymbol]: (prev.borrowed[tokenSymbol] || 0) + parseFloat(amount)\n        };\n\n        // Calculate new health factor\n        const totalBorrowedValue = Object.entries(newBorrowed).reduce((total, [symbol, amt]) => {\n          const tokenMarket = marketData.markets.find(m => m.symbol === symbol);\n          return total + amt * ((tokenMarket === null || tokenMarket === void 0 ? void 0 : tokenMarket.price) || 0);\n        }, 0);\n        const newHealth = prev.collateralValue > 0 ? prev.collateralValue / totalBorrowedValue * 100 : 100;\n        return {\n          ...prev,\n          borrowed: newBorrowed,\n          health: Math.min(newHealth, 100)\n        };\n      });\n      return {\n        success: true,\n        message: `Successfully borrowed ${amount} ${tokenSymbol}`\n      };\n    } catch (error) {\n      return {\n        success: false,\n        message: error.message\n      };\n    }\n  };\n\n  // Calculate APY for supplied assets\n  const calculateSupplyAPY = tokenSymbol => {\n    const market = marketData.markets.find(m => m.symbol === tokenSymbol);\n    return market ? market.supplyApy : 0;\n  };\n\n  // Calculate APY for borrowed assets\n  const calculateBorrowAPY = tokenSymbol => {\n    const market = marketData.markets.find(m => m.symbol === tokenSymbol);\n    return market ? market.borrowApy : 0;\n  };\n\n  // Value to be provided by the context\n  const value = {\n    marketData: marketData.markets,\n    isLoading: marketData.loading,\n    error: marketData.error,\n    userCompound,\n    simulateSupply,\n    simulateBorrow,\n    calculateSupplyAPY,\n    calculateBorrowAPY\n  };\n  return /*#__PURE__*/_jsxDEV(CompoundContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 168,\n    columnNumber: 5\n  }, this);\n};\n_s2(CompoundProvider, \"VwLx3hueBvyu2K9sB7bd3gjEhws=\");\n_c = CompoundProvider;\nvar _c;\n$RefreshReg$(_c, \"CompoundProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","compoundService","jsxDEV","_jsxDEV","CompoundContext","useCompound","_s","CompoundProvider","children","_s2","marketData","setMarketData","markets","loading","error","userCompound","setUserCompound","supplied","borrowed","health","collateralValue","fetchMarketData","data","getMarkets","message","intervalId","setInterval","clearInterval","simulateSupply","tokenSymbol","amount","market","find","m","symbol","Error","exchangeRate","cTokenAmount","prev","parseFloat","price","success","simulateBorrow","borrowValueInUSD","maxBorrow","newBorrowed","totalBorrowedValue","Object","entries","reduce","total","amt","tokenMarket","newHealth","Math","min","calculateSupplyAPY","supplyApy","calculateBorrowAPY","borrowApy","value","isLoading","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/User/Documents/GitHub/LearnFi/learnfi/src/context/CompoundContext.jsx"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect } from 'react';\nimport { compoundService } from '../services/compoundService';\n\n// Create context\nconst CompoundContext = createContext();\n\n// Custom hook to use the compound context\nexport const useCompound = () => useContext(CompoundContext);\n\nexport const CompoundProvider = ({ children }) => {\n  // Market data state\n  const [marketData, setMarketData] = useState({\n    markets: [],\n    loading: true,\n    error: null\n  });\n\n  // User's compound state (simulated)\n  const [userCompound, setUserCompound] = useState({\n    supplied: {},\n    borrowed: {},\n    health: 100,\n    collateralValue: 0\n  });\n\n  // Fetch market data on mount\n  useEffect(() => {\n    const fetchMarketData = async () => {\n      try {\n        const data = await compoundService.getMarkets();\n        setMarketData({\n          markets: data,\n          loading: false,\n          error: null\n        });\n      } catch (error) {\n        setMarketData({\n          markets: [],\n          loading: false,\n          error: error.message\n        });\n      }\n    };\n\n    fetchMarketData();\n    \n    // Refresh market data every 60 seconds\n    const intervalId = setInterval(fetchMarketData, 60000);\n    \n    return () => clearInterval(intervalId);\n  }, []);\n\n  // Simulate supplying assets\n  const simulateSupply = async (tokenSymbol, amount) => {\n    try {\n      // Get current market data for the token\n      const market = marketData.markets.find(m => m.symbol === tokenSymbol);\n      if (!market) {\n        throw new Error(`Market for ${tokenSymbol} not found`);\n      }\n      \n      // Calculate cToken amount (simplified)\n      const exchangeRate = market.exchangeRate || 0.02; // Default if not available\n      const cTokenAmount = amount / exchangeRate;\n      \n      // Update user's compound state\n      setUserCompound(prev => ({\n        ...prev,\n        supplied: {\n          ...prev.supplied,\n          [tokenSymbol]: (prev.supplied[tokenSymbol] || 0) + parseFloat(amount)\n        },\n        collateralValue: prev.collateralValue + (parseFloat(amount) * market.price)\n      }));\n      \n      return {\n        success: true,\n        cTokenAmount,\n        message: `Successfully supplied ${amount} ${tokenSymbol}`\n      };\n    } catch (error) {\n      return {\n        success: false,\n        message: error.message\n      };\n    }\n  };\n\n  // Simulate borrowing assets\n  const simulateBorrow = async (tokenSymbol, amount) => {\n    try {\n      // Get current market data for the token\n      const market = marketData.markets.find(m => m.symbol === tokenSymbol);\n      if (!market) {\n        throw new Error(`Market for ${tokenSymbol} not found`);\n      }\n      \n      // Check if user has enough collateral\n      const borrowValueInUSD = parseFloat(amount) * market.price;\n      const maxBorrow = userCompound.collateralValue * 0.75; // 75% of collateral value\n      \n      if (borrowValueInUSD > maxBorrow) {\n        throw new Error(`Not enough collateral to borrow ${amount} ${tokenSymbol}`);\n      }\n      \n      // Update user's compound state\n      setUserCompound(prev => {\n        const newBorrowed = {\n          ...prev.borrowed,\n          [tokenSymbol]: (prev.borrowed[tokenSymbol] || 0) + parseFloat(amount)\n        };\n        \n        // Calculate new health factor\n        const totalBorrowedValue = Object.entries(newBorrowed)\n          .reduce((total, [symbol, amt]) => {\n            const tokenMarket = marketData.markets.find(m => m.symbol === symbol);\n            return total + (amt * (tokenMarket?.price || 0));\n          }, 0);\n        \n        const newHealth = prev.collateralValue > 0 \n          ? (prev.collateralValue / totalBorrowedValue) * 100\n          : 100;\n        \n        return {\n          ...prev,\n          borrowed: newBorrowed,\n          health: Math.min(newHealth, 100)\n        };\n      });\n      \n      return {\n        success: true,\n        message: `Successfully borrowed ${amount} ${tokenSymbol}`\n      };\n    } catch (error) {\n      return {\n        success: false,\n        message: error.message\n      };\n    }\n  };\n\n  // Calculate APY for supplied assets\n  const calculateSupplyAPY = (tokenSymbol) => {\n    const market = marketData.markets.find(m => m.symbol === tokenSymbol);\n    return market ? market.supplyApy : 0;\n  };\n\n  // Calculate APY for borrowed assets\n  const calculateBorrowAPY = (tokenSymbol) => {\n    const market = marketData.markets.find(m => m.symbol === tokenSymbol);\n    return market ? market.borrowApy : 0;\n  };\n\n  // Value to be provided by the context\n  const value = {\n    marketData: marketData.markets,\n    isLoading: marketData.loading,\n    error: marketData.error,\n    userCompound,\n    simulateSupply,\n    simulateBorrow,\n    calculateSupplyAPY,\n    calculateBorrowAPY\n  };\n\n  return (\n    <CompoundContext.Provider value={value}>\n      {children}\n    </CompoundContext.Provider>\n  );\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}